<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Simfony Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Types and Values</li><li class="chapter-item expanded "><a href="type.html"><strong aria-hidden="true">1.</strong> Types and Values</a></li><li class="chapter-item expanded "><a href="type_alias.html"><strong aria-hidden="true">2.</strong> Type Aliases</a></li><li class="chapter-item expanded "><a href="type_casting.html"><strong aria-hidden="true">3.</strong> Type Casting</a></li><li class="chapter-item expanded affix "><li class="part-title">Writing a Program</li><li class="chapter-item expanded "><a href="let_statement.html"><strong aria-hidden="true">4.</strong> Let Statements</a></li><li class="chapter-item expanded "><a href="match_expression.html"><strong aria-hidden="true">5.</strong> Match Expression</a></li><li class="chapter-item expanded "><a href="function.html"><strong aria-hidden="true">6.</strong> Functions</a></li><li class="chapter-item expanded "><a href="program.html"><strong aria-hidden="true">7.</strong> Programs</a></li><li class="chapter-item expanded affix "><li class="part-title">Locking and Unlocking UTXOs</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Simfony Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Simfony is a high-level language for writing Bitcoin smart contracts.
In other words, Simfony is a language for expressing spending conditions of UTXOs on the Bitcoin blockchain.</p>
<p>Simfony looks and feels like <a href="https://www.rust-lang.org/">Rust</a>.
Developers write Simfony, Bitcoin full nodes run Simplicity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-and-values"><a class="header" href="#types-and-values">Types and Values</a></h1>
<p>Simfony mostly uses a subset of Rust's types.
It extends Rust in some ways to make it work better with Simplicity and with the blockchain.</p>
<h2 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Values</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>Boolean</td><td><code>false</code>, <code>true</code></td></tr>
</tbody></table>
</div>
<p>Values of type <code>bool</code> are truth values, which are either <code>true</code> or <code>false</code>.</p>
<h2 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Values</th></tr></thead><tbody>
<tr><td><code>u1</code></td><td>1-bit integer</td><td><code>0</code>, <code>1</code></td></tr>
<tr><td><code>u2</code></td><td>2-bit integer</td><td><code>0</code>, <code>1</code>, <code>2</code>, <code>3</code></td></tr>
<tr><td><code>u4</code></td><td>4-bit integer</td><td><code>0</code>, <code>1</code>, …, <code>15</code></td></tr>
<tr><td><code>u8</code></td><td>8-bit integer</td><td><code>0</code>, <code>1</code>, …, <code>255</code></td></tr>
<tr><td><code>u16</code></td><td>16-bit integer</td><td><code>0</code>, <code>1</code>, …, <code>65535</code></td></tr>
<tr><td><code>u32</code></td><td>32-bit integer</td><td><code>0</code>, <code>1</code>, …, <code>4294967295</code></td></tr>
<tr><td><code>u64</code></td><td>64-bit integer</td><td><code>0</code>, <code>1</code>, …, <code>18446744073709551615</code></td></tr>
<tr><td><code>u128</code></td><td>128-bit integer</td><td><code>0</code>, <code>1</code>, …, <code>340282366920938463463374607431768211455</code></td></tr>
<tr><td><code>u256</code></td><td>256-bit integer</td><td><code>0</code>, <code>1</code>, …, 2<sup>256</sup> - 1<sup class="footnote-reference"><a href="#u256max">1</a></sup></td></tr>
</tbody></table>
</div>
<p>Unsigned integers range from 1 bit to 256 bits.
<a href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code></a> to <a href="https://doc.rust-lang.org/std/primitive.u128.html"><code>u128</code></a> are also supported in Rust.
<code>u1</code>, <code>u2</code>, <code>u4</code> and <code>u256</code> are new to Simfony.
Integer values can be written in decimal notation <code>123456</code>, binary notation<sup class="footnote-reference"><a href="#bin">2</a></sup> <code>0b10101010</code> or hexadecimal notation<sup class="footnote-reference"><a href="#hex">3</a></sup> <code>0xdeadbeef</code>.
There are no signed integers.</p>
<div class="footnote-definition" id="u256max"><sup class="footnote-definition-label">1</sup>
<p>The maximal value of type <code>u256</code> is <code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code>.</p>
</div>
<div class="footnote-definition" id="bin"><sup class="footnote-definition-label">2</sup>
<p>The number of bits must be equal to the bit width of the type.</p>
</div>
<div class="footnote-definition" id="hex"><sup class="footnote-definition-label">3</sup>
<p>The number of hex digits must correspond to the bit width of the type.</p>
</div>
<h2 id="tuple-types"><a class="header" href="#tuple-types">Tuple Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Values</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>0-tuple</td><td><code>()</code></td></tr>
<tr><td><code>(A)</code></td><td>1-tuple</td><td><code>(a0,)</code>, <code>(a1,)</code>, …</td></tr>
<tr><td><code>(A, B)</code></td><td>2-tuple</td><td><code>(a0, b0)</code>, <code>(a1, b1)</code>, <code>(a2, b2)</code>, <code>(a3, b3)</code>, …</td></tr>
<tr><td>…</td><td>…</td><td>…</td></tr>
<tr><td><code>(A, B, …)</code></td><td>n-tuple</td><td><code>(a0, b0, …)</code>, …</td></tr>
</tbody></table>
</div>
<p><a href="https://doc.rust-lang.org/std/primitive.tuple.html">Tuples work just like in Rust</a>.</p>
<p>The empty tuple <code>()</code> contains no information.
It is also called the "unit".
It is mostly used as the return type of functions that don't return anything.</p>
<p>Singletons <code>(a0,)</code> must be written with an extra comma <code>,</code> to differentiate them from function calls.</p>
<p>Bigger tuples <code>(a0, b0, …)</code> work like in pretty much any other programming language.
Each tuple type <code>(A1, A2, …, AN)</code> defines a sequence <code>A1</code>, <code>A2</code>, …, <code>AN</code> of types.
Values of that type must mirror the sequence of types:
A tuple value <code>(a1, a2, …, aN)</code> consists of a sequence <code>a1</code>, <code>a2</code>, …, <code>aN</code> of values, where <code>a1</code> is of type <code>A1</code>, <code>a2</code> is of type <code>A2</code>, and so on.
Tuples are always finite in length.</p>
<blockquote>
<p>Tuples are different from arrays:
Each element of a tuple can have a different type.
Each element of an array must have the same type.</p>
</blockquote>
<h2 id="array-types"><a class="header" href="#array-types">Array Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Values</th></tr></thead><tbody>
<tr><td><code>[A; 0]</code></td><td>0-array</td><td><code>[]</code></td></tr>
<tr><td><code>[A; 1]</code></td><td>1-array</td><td><code>[a0]</code>, <code>[a1]</code>, …</td></tr>
<tr><td><code>[A; 2]</code></td><td>2-array</td><td><code>[a0, a1]</code>, <code>[a2, a3]</code>, <code>[a4, a5]</code>, <code>[a6, a7]</code>, …</td></tr>
<tr><td>…</td><td>…</td><td>…</td></tr>
<tr><td><code>[A; N]</code></td><td>n-array</td><td><code>[a0, …, aN]</code>, …</td></tr>
</tbody></table>
</div>
<p><a href="https://doc.rust-lang.org/std/primitive.array.html">Arrays work just like in Rust</a>.</p>
<p>The empty array <code>[]</code> is basically useless, but I included it for completeness.</p>
<p>Arrays <code>[a0, …, aN]</code> work like in pretty much any other programming language.
Each array type <code>[A; N]</code> defines an element type <code>A</code> and a length <code>N</code>.
An array value <code>[a0, …, aN]</code> of that type consists of <code>N</code> many elements <code>a0</code>, …, <code>aN</code> that are each of type <code>A</code>.
Arrays are always of finite length.</p>
<blockquote>
<p>Arrays are different from tuples:
Each element of an array must have the same type.
Each element of a tuple can have a different type.</p>
</blockquote>
<h2 id="list-types"><a class="header" href="#list-types">List Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Values</th></tr></thead><tbody>
<tr><td><code>List&lt;A, 2&gt;</code></td><td>&lt;2-list</td><td><code>list![]</code>, <code>list![a1]</code></td></tr>
<tr><td><code>List&lt;A, 4&gt;</code></td><td>&lt;4-list</td><td><code>list![]</code>, …, <code>list![a1, a2, a3]</code></td></tr>
<tr><td><code>List&lt;A, 8&gt;</code></td><td>&lt;8-list</td><td><code>list![]</code>, …, <code>list![a1, …, a7]</code></td></tr>
<tr><td><code>List&lt;A, 16&gt;</code></td><td>&lt;16-list</td><td><code>list![]</code>, …, <code>list![a1, …, a15]</code></td></tr>
<tr><td><code>List&lt;A, 32&gt;</code></td><td>&lt;32-list</td><td><code>list![]</code>, …, <code>list![a1, …, a31]</code></td></tr>
<tr><td><code>List&lt;A, 64&gt;</code></td><td>&lt;64-list</td><td><code>list![]</code>, …, <code>list![a1, …, a62]</code></td></tr>
<tr><td><code>List&lt;A, 128&gt;</code></td><td>&lt;128-list</td><td><code>list![]</code>, …, <code>list![a1, …, a127]</code></td></tr>
<tr><td><code>List&lt;A, 256&gt;</code></td><td>&lt;256-list</td><td><code>list![]</code>, …, <code>list![a1, …, a255]</code></td></tr>
<tr><td><code>List&lt;A, 512&gt;</code></td><td>&lt;512-list</td><td><code>list![]</code>, …, <code>list![a1, …, a511]</code></td></tr>
<tr><td>…</td><td>…</td><td>…</td></tr>
<tr><td><code>List&lt;A,</code>2<sup>N</sup><code>&gt;</code></td><td>&lt;2<sup>N</sup>-list</td><td><code>list![]</code>, …, <code>list![a1, …, a</code>(2<sup>N</sup> - 1)<code>]</code></td></tr>
</tbody></table>
</div>
<p>Lists hold a variable number of elements of the same type.
This is similar to <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Rust vectors</a>, but Simfony doesn't have a heap.
In Simfony, lists exists on the stack, which is why the maximum list length is bounded.</p>
<p>&lt;2-lists hold fewer than 2 elements, so zero or one element.
&lt;4-lists hold fewer than 4 elements, so zero to three elements.
&lt;8-lists hold fewer than 8 elements, so zero to seven elements.
And so on.
For technical reasons, the list bound is always a power of two.
The bound 1 is not supported, because it would only allow empty lists, which is useless.</p>
<blockquote>
<p>Lists are different from arrays:
List values hold a variable number of elements.
Array values hold a fixed number of elements.</p>
</blockquote>
<p>On the blockchain, you pay for every byte that you use.
If you use an array, then you pay for every single element.
For example, values of type <code>[u8; 512]</code> cost roughly as much as 512 many <code>u8</code> values.
However, if you use a list, then you only pay for the elements that you actually use.
For example, the type <code>List&lt;u8, 512&gt;</code> allows for up to 511 elements.
If you only use three elements <code>list![1, 2, 3]</code>, then you pay for exactly three elements.
You <strong>don't</strong> pay for the remaining 508 unused elements.</p>
<h2 id="option-types"><a class="header" href="#option-types">Option Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Values</th></tr></thead><tbody>
<tr><td><code>Option&lt;A&gt;</code></td><td><code>None</code>, <code>Some(a0)</code>, <code>Some(a1)</code>, …</td></tr>
</tbody></table>
</div>
<p>Options represent values that might not be present. <a href="https://doc.rust-lang.org/std/option/index.html">They work just like in Rust</a>.</p>
<p>An option type is generic over a type <code>A</code>.
The value <code>None</code> is empty.
The value <code>Some(a)</code> contains an inner value <code>a</code> of type <code>A</code>.</p>
<p>In Rust, we implement options as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;A&gt; {
    None,
    Some(A),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="either-types"><a class="header" href="#either-types">Either Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Values</th></tr></thead><tbody>
<tr><td><code>Either&lt;A, B&gt;</code></td><td><code>Left(a0)</code>, <code>Left(a1)</code>, …, <code>Right(b0)</code>, <code>Right(b1)</code>, …</td></tr>
</tbody></table>
</div>
<p>Sum types represent values that are of some "left" type in some cases and that are of another "right" type in other cases.
<a href="https://docs.rs/either/latest/either/enum.Either.html">They work just like in the either crate</a>.
<a href="https://doc.rust-lang.org/std/result/index.html">The Result type from Rust is very similar, too</a>.</p>
<p>A sum type type is generic over two types, <code>A</code> and <code>B</code>.
The value <code>Left(a)</code> contains an inner value <code>a</code> of type <code>A</code>.
The value <code>Right(b)</code> contains an inner value <code>b</code> of type <code>B</code>.</p>
<p>In Rust, we implement sum types as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h1>
<p>Simfony currently doesn't support Rust-like <code>struct</code>s for organizing data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
  active: bool,
  id: u256,
  sign_in_count: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Simfony programmers have to handle long tuples of unlabeled data, which can get messy.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(bool, u256, u64)
<span class="boring">}</span></code></pre></pre>
<p>To help with the situation, programmers can define custom type aliases.
Aliases define a new name for an existing type.
In contrast, <code>struct</code>s define an entirely new type, so aliases are different from <code>struct</code>s.
However, aliases still help us to make the code more readable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type User = (bool, u256, u64);
<span class="boring">}</span></code></pre></pre>
<p>There is also a list of builtin type aliases.
These aliases can be used without defining them.</p>
<div class="table-wrapper"><table><thead><tr><th>Builtin Alias</th><th>Definition</th></tr></thead><tbody>
<tr><td><code>Amount1</code></td><td><code>Either&lt;(u1, u256), u64&gt;</code></td></tr>
<tr><td><code>Asset1</code></td><td><code>Either&lt;(u1, u256), u256&gt;</code></td></tr>
<tr><td><code>Confidential1</code></td><td><code>(u1, u256)</code></td></tr>
<tr><td><code>Ctx8</code></td><td><code>(List&lt;u8, 64&gt;, (u64, u256))</code></td></tr>
<tr><td><code>Distance</code></td><td><code>u16</code></td></tr>
<tr><td><code>Duration</code></td><td><code>u16</code></td></tr>
<tr><td><code>ExplicitAmount</code></td><td><code>u256</code></td></tr>
<tr><td><code>ExplicitAsset</code></td><td><code>u256</code></td></tr>
<tr><td><code>ExplicitNonce</code></td><td><code>u256</code></td></tr>
<tr><td><code>Fe</code></td><td><code>u256</code></td></tr>
<tr><td><code>Ge</code></td><td><code>(u256, u256)</code></td></tr>
<tr><td><code>Gej</code></td><td><code>((u256, u256), u256)</code></td></tr>
<tr><td><code>Height</code></td><td><code>u32</code></td></tr>
<tr><td><code>Lock</code></td><td><code>u32</code></td></tr>
<tr><td><code>Message</code></td><td><code>u256</code></td></tr>
<tr><td><code>Message64</code></td><td><code>[u8; 64]</code></td></tr>
<tr><td><code>Nonce</code></td><td><code>Either&lt;(u1, u256), u256&gt;</code></td></tr>
<tr><td><code>Outpoint</code></td><td><code>(u256, u32)</code></td></tr>
<tr><td><code>Point</code></td><td><code>(u1, u256)</code></td></tr>
<tr><td><code>Pubkey</code></td><td><code>u256</code></td></tr>
<tr><td><code>Scalar</code></td><td><code>u256</code></td></tr>
<tr><td><code>Signature</code></td><td><code>[u8; 64]</code></td></tr>
<tr><td><code>Time</code></td><td><code>u32</code></td></tr>
<tr><td><code>TokenAmount1</code></td><td><code>Either&lt;(u1, u256), u64&gt;</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="casting"><a class="header" href="#casting">Casting</a></h1>
<p>A Simfony type can be cast into another Simfony type if both types share the same structure.
The structure of a type has to do with how the type is implemented on the Simplicity "processor".
I will spare you the boring details.</p>
<p>Below is a table of types that can be cast into each other.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Casts To (And Back)</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>Either&lt;(), ()&gt;</code></td></tr>
<tr><td><code>Option&lt;A&gt;</code></td><td><code>Either&lt;(), A&gt;</code></td></tr>
<tr><td><code>u1</code></td><td><code>bool</code></td></tr>
<tr><td><code>u2</code></td><td><code>(u1, u1)</code></td></tr>
<tr><td><code>u4</code></td><td><code>(u2, u2)</code></td></tr>
<tr><td><code>u8</code></td><td><code>(u4, u4)</code></td></tr>
<tr><td><code>u16</code></td><td><code>(u8, u8)</code></td></tr>
<tr><td><code>u32</code></td><td><code>(u16, u16)</code></td></tr>
<tr><td><code>u64</code></td><td><code>(u32, u32)</code></td></tr>
<tr><td><code>u128</code></td><td><code>(u64, u64)</code></td></tr>
<tr><td><code>u256</code></td><td><code>(u128, u128)</code></td></tr>
<tr><td><code>(A)</code></td><td><code>A</code></td></tr>
<tr><td><code>(A, B, C)</code></td><td><code>(A, (B, C))</code></td></tr>
<tr><td><code>(A, B, C, D)</code></td><td><code>((A, B), (C, D))</code></td></tr>
<tr><td>…</td><td>…</td></tr>
<tr><td><code>[A; 0]</code></td><td><code>()</code></td></tr>
<tr><td><code>[A; 1]</code></td><td><code>A</code></td></tr>
<tr><td><code>[A; 2]</code></td><td><code>(A, A)</code></td></tr>
<tr><td><code>[A; 3]</code></td><td><code>(A, (A, A))</code></td></tr>
<tr><td><code>[A; 4]</code></td><td><code>((A, A), (A, A))</code></td></tr>
<tr><td>…</td><td>…</td></tr>
<tr><td><code>List&lt;A, 2&gt;</code></td><td><code>Option&lt;A&gt;</code></td></tr>
<tr><td><code>List&lt;A, 4&gt;</code></td><td><code>(Option&lt;[A; 2]&gt;, List&lt;A, 2&gt;)</code></td></tr>
<tr><td><code>List&lt;A, 8&gt;</code></td><td><code>(Option&lt;[A; 4]&gt;, List&lt;A, 4&gt;)</code></td></tr>
<tr><td><code>List&lt;A, 16&gt;</code></td><td><code>(Option&lt;[A; 8]&gt;, List&lt;A, 8&gt;)</code></td></tr>
<tr><td><code>List&lt;A, 32&gt;</code></td><td><code>(Option&lt;[A; 16]&gt;, List&lt;A, 16&gt;)</code></td></tr>
<tr><td><code>List&lt;A, 64&gt;</code></td><td><code>(Option&lt;[A; 32]&gt;, List&lt;A, 32&gt;)</code></td></tr>
<tr><td><code>List&lt;A, 128&gt;</code></td><td><code>(Option&lt;[A; 64]&gt;, List&lt;A, 64&gt;)</code></td></tr>
<tr><td><code>List&lt;A, 256&gt;</code></td><td><code>(Option&lt;[A; 128]&gt;, List&lt;A, 128&gt;)</code></td></tr>
<tr><td><code>List&lt;A, 512&gt;</code></td><td><code>(Option&lt;[A; 256]&gt;, List&lt;A, 256&gt;)</code></td></tr>
<tr><td>…</td><td>…</td></tr>
</tbody></table>
</div>
<h2 id="casting-rules"><a class="header" href="#casting-rules">Casting Rules</a></h2>
<p>Type <code>A</code> can be cast into itself (reflexivity).</p>
<p>If type <code>A</code> can be cast into type <code>B</code>, then type <code>B</code> can be cast into type <code>A</code> (symmetry).</p>
<p>If type <code>A</code> can be cast into type <code>B</code> and type <code>B</code> can be cast into type <code>C</code>, then type <code>A</code> can be cast into type <code>C</code> (transitivity).</p>
<h2 id="casting-expression"><a class="header" href="#casting-expression">Casting Expression</a></h2>
<p>All casting in Simfony happens explicitly through a casting expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;Input&gt;::into(input)
<span class="boring">}</span></code></pre></pre>
<p>The above expression casts the value <code>input</code> of type <code>Input</code> into some output type.
The input type of the cast is explict while the output type is implicit.</p>
<p>In Simfony, the output type of every expression is known.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 1;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the meaning of the expression <code>1</code> is clear because of the type <code>u32</code> of variable <code>x</code>.
Here, <code>1</code> means a string of 31 zeroes and 1 one.
<em>In other contexts, <code>1</code> could mean something different, like a string of 255 zeroes and 1 one.</em></p>
<p>The Simfony compiler knows the type of the outermost expression, and it tries to infer the types of inner expressions based on that.
When it comes to casting expressions, the compiler has no idea about the input type of the cast.
The programmer needs to supply this information by annotating the cast with its input type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = &lt;(u16, u16)&gt;::into((0, 1));
<span class="boring">}</span></code></pre></pre>
<p>In the above example, we cast the tuple <code>(0, 1)</code> of type <code>(u16, u16)</code> into type <code>u32</code>.
Feel free to consult the table above to verify that this is valid cast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-statement"><a class="header" href="#let-statement">Let Statement</a></h1>
<p>Variables are defined in let statements, <a href="https://doc.rust-lang.org/std/keyword.let.html">just like in Rust</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 1;
<span class="boring">}</span></code></pre></pre>
<p>The above let statement defines a variable called <code>x</code>.
The variable is of type <code>u32</code> and it is assigned the value <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = f(1337);
<span class="boring">}</span></code></pre></pre>
<p>Variables can be assigned to the output value of any expression, such as function calls.</p>
<h2 id="explicit-typing"><a class="header" href="#explicit-typing">Explicit typing</a></h2>
<p>In Simfony, the type of a defined variable <strong>always</strong> has to be written.
This is different from Rust, which has better type inference.</p>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p>Simfony variables are <strong>always</strong> immutable.
There are no mutable variables.</p>
<h2 id="redefinition-and-scoping"><a class="header" href="#redefinition-and-scoping">Redefinition and scoping</a></h2>
<p>The same variable can be defined twice in the same scope.
The later definition overrides the earlier definition.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 1;
let x: u32 = 2;
assert!(jet::eq_32(x, 2)); // x == 2
<span class="boring">}</span></code></pre></pre>
<p>Normal scoping rules apply:
Variables from outer scopes are available inside inner scopes.
A variable defined in an inner scope shadows a variable of the same name from an outer scope.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 1;
let y: u32 = 2;
let z: u32 = {
    let x: u32 = 3;
    assert!(jet::eq_32(y, 2)); // y == 2
    x
};
assert!(jet::eq_32(x, 3)); // z == 3
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h2>
<p>There is limited pattern matching support inside let statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y, _): (u8, u16, u32) = (1, 2, 3);
let [x, _, z]: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>In the first line, the tuple <code>(1, 2, 3)</code> is deconstructed into the values <code>1</code>, <code>2</code> and <code>3</code>.
These values are assigned to the variable names <code>x</code>, <code>y</code> and <code>_</code>.
The variable name <code>_</code> is a special name that ignores its value.
In the end, two variables are created: <code>x: u32 = 1</code> and <code>y: u16 = 2</code>.</p>
<p>Similarly, arrays can be deconstructed element by element and assigned to a variable each.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-expression"><a class="header" href="#match-expression">Match Expression</a></h1>
<p>A match expression conditionally executes code branches.
Which branch is executed depends on the input to the match expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: u32 = match f(42) {
    Left(x: u32) =&gt; x,
    Right(x: u16) =&gt; jet::left_pad_low_16_32(x),
};
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the output of the function call <code>f(42)</code> is matched.
<code>f</code> returns an output of type <code>Either&lt;u32, u16&gt;</code>.
If <code>f(42)</code> returns a value that matches the pattern <code>Left(x: u32)</code>, then the first match arm is executed.
This arm simply returns the value <code>x</code>.
Alternatively, if <code>f(42)</code> returns a value that matches the pattern <code>Right(x: u16)</code>, then the second match arm is executed.
This arm extends the 16-bit number <code>x</code> to a 32-bit number by padding its left with zeroes.
Because of type constraints, the output of <code>f</code> must match one of these two patterns.
The whole match expression returns a value of type <code>u32</code>, from one of the two arms.</p>
<h2 id="explicit-typing-1"><a class="header" href="#explicit-typing-1">Explicit typing</a></h2>
<p>In Simfony, the type of variables inside match arms must <strong>always</strong> be written.
This is different from Rust, which has better type inference.</p>
<h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern matching</a></h2>
<p>There is limited support for pattern matching inside match expressions.</p>
<p>Boolean values can be matched.
The Boolean match expression is the replacement for an "if-then-else" in Simfony.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bit_flip: bool = match false {
    false =&gt; true,
    true =&gt; false,
};
<span class="boring">}</span></code></pre></pre>
<p>Optional values can be matched.
The <code>Some</code> arm introduces a variable which must be explicitly typed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unwrap_or_default: u32 = match Some(42) {
    None =&gt; 0,
    Some(x: u32) =&gt; x,
};
<span class="boring">}</span></code></pre></pre>
<p>Finally, <code>Either</code> values can be matched.
Again, variables that are introduced in match arms must be explicitly typed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map_either: u32 = match Left(1337) {
    Left(x: u32) =&gt; f(x),
    Right(y: u32) =&gt; f(y),
};
<span class="boring">}</span></code></pre></pre>
<p>Match expressions don't support further pattern matching, in contrast to Rust.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unwrap_or_default: u32 = match Some((4, 2)) {
    None =&gt; 0,
    // this doesn't compile
    Some((y, z): (u16, u16)) =&gt; &lt;(u16, u16)&gt;::into((y, z)),
};
<span class="boring">}</span></code></pre></pre>
<p>However, the match arm can contain code that performs the deconstruction.
For example, the tuple <code>x</code> of type <code>(u16, u16)</code> can be deconstructed into two integers <code>y</code> and <code>z</code> of type <code>u16</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unwrap_or_default: u32 = match Some((4, 2)) {
    None =&gt; 0,
    Some(x: (u16, u16)) =&gt; {
        let (y, z): (u16, u16) = x;
        &lt;(u16, u16)&gt;::into((y, z))
    }
};
<span class="boring">}</span></code></pre></pre>
<p>The match arm can also contain match expressions for further deconstruction.
For example, the sum value <code>x</code> of type <code>Either&lt;u32, u32&gt;</code> can be matched as either <code>Left(y: u32)</code> or <code>Right(z: u32)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unwrap_or_default: u32 = match Some(Left(42)) {
    None =&gt; 0,
    Some(x: Either&lt;u32, u32&gt;) =&gt; match x {
        Left(y: u32) =&gt; y,
        Right(z: u32) =&gt; z,
    },
};
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are defined and called <a href="https://doc.rust-lang.org/std/keyword.fn.html">just like in Rust</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: u32, y: u32) -&gt; u32 {
    let (carry, sum): (bool, u32) = jet::add_32(x, y);
    match carry {
        true =&gt; panic!(), // overflow
        false =&gt; {}, // ok
    };
    sum
}
<span class="boring">}</span></code></pre></pre>
<p>The above example defines a function called <code>add</code> that takes two parameters: variable <code>x</code> of type <code>u32</code> and variable <code>y</code> of type <code>u32</code>. The function returns a value of type <code>u32</code>.</p>
<p>The body of the function is a block expression <code>{ ... }</code> that is executed from top to bottom.
The function returns on the final line <em>(note the missing semicolon <code>;</code>)</em>.
In the above example, <code>x</code> and <code>y</code> are added via the <code>add_32</code> jet.
The function then checks if the carry is true, signaling an overflow, in which case it panics.
On the last line, the value of <code>sum</code> is returned.</p>
<p>The above function is called by writing its name <code>add</code> followed by a list of arguments <code>(40, 2)</code>.
Each parameter needs an argument, so the list of arguments is as long as the list of arguments.
Here, <code>x</code> is assigned the value <code>40</code> and <code>y</code> is assigned the value <code>2</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let z: u32 = add(40, 2);
<span class="boring">}</span></code></pre></pre>
<h2 id="no-early-returns"><a class="header" href="#no-early-returns">No early returns</a></h2>
<p>Simfony has no support for an early return via a "return" keyword.
The only branching that is available is via <a href="./match_expression.html">match expressions</a>.</p>
<h2 id="no-recursion"><a class="header" href="#no-recursion">No recursion</a></h2>
<p>Simfony has no support for recursive function calls.
A function can be called inside a function body if it has been defined before.
This means that a function cannot call itself.
Loops, where <code>f</code> calls <code>g</code> and <code>g</code> calls <code>f</code>, are also impossible.</p>
<p>What <em>is</em> possible are stratified function definitions, where level-0 functions depend on nothing, level-1 functions depend on level-0 functions, and so on.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn level_0() -&gt; u32 {
    0
}

fn level_1() -&gt; u32 {
    let (_, next) = jet::increment_32(level_0());
    next
}

fn level_2() -&gt; u32 {
    let (_, next) = jet::increment_32(level_1));
    next
}
<span class="boring">}</span></code></pre></pre>
<h2 id="order-matters"><a class="header" href="#order-matters">Order matters</a></h2>
<p>If function <code>g</code> calls function <code>f</code>, then <code>f</code> <strong>must</strong> be defined before <code>g</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() -&gt; u32 {
    42
}

fn g() -&gt; u32 {
    f()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="main-function"><a class="header" href="#main-function">Main function</a></h2>
<p>The <code>main</code> function is the entry point of each Simfony program.
Running a program means running its <code>main</code> function.
Other functions are called from the <code>main</code> function.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // ...
}</code></pre></pre>
<p>The <code>main</code> function is a reserved name and must exist in every program.
Simfony programs are always "binaries".
There is no support for "libraries".</p>
<h2 id="jets"><a class="header" href="#jets">Jets</a></h2>
<p>Jets are predefined and optimized functions for common usecases.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>jet::add_32(40, 2)
<span class="boring">}</span></code></pre></pre>
<p>Jets live inside the namespace <code>jet</code>, which is why they are prefixed with <code>jet::</code>.
They can be called without defining them manually.</p>
<p>It is usually more efficient to call a jet than to manually compute a value.</p>
<p><a href="https://docs.rs/simfony-as-rust/latest/simfony_as_rust/jet/index.html">The jet documentation</a> lists each jet and explains what it does.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programs"><a class="header" href="#programs">Programs</a></h1>
<p>A Simfony program consists of a <code>main</code> <a href="./function.html">function</a>.</p>
<p>A program may also have <a href="./type_alias.html">type aliases</a> or custom <a href="./function.html">function definitions</a>.
The <code>main</code> function comes last in the program, because everything it calls must be defined before it.</p>
<pre><pre class="playground"><code class="language-rust">type Furlong = u32;
type Mile = u32;

fn to_miles(distance: Either&lt;Furlong, Mile&gt;) -&gt; Mile {
    match distance {
        Left(furlongs: Furlong) =&gt; jet::divide_32(furlongs, 8),
        Right(miles: Mile) =&gt; miles,
    }
}

fn main() {
    let eight_furlongs: Either&lt;Furlong, Mile&gt; = Left(8);
    let one_mile: Either&lt;Furlong, Mile&gt; = Right(1);
    assert!(jet::eq_32(1, to_miles(eight_furlongs)));
    assert!(jet::eq_32(1, to_miles(one_mile)));
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
